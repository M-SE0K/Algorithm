/*
 BOJ-1965 상자넣기
 문제 :
 정육면체 모양의 상자가 일렬로 늘어서 있다. 상자마다 크기가 주어져 있는데, 앞에 있는 상자의 크기가 뒤에 있는 상자의 크기보다 작으면, 앞에 있는 상자를 뒤에 있는 상자 안에 넣을 수가 있다. 예를 들어 앞에서부터 순서대로 크기가(1, 5, 2, 3, 7)인 5개의 상자가 있다면, 크기 1인 상자를 크기 5인 상자에 넣고, 다시 이 상자를 크기 7인 상자 안에 넣을 수 있다. 하지만 이렇게 상자를 넣을 수 있는 방법은 여러 가지가 있을 수 있다. 앞의 예에서 차례대로 크기가 1, 2, 3, 7인 상자를 선택하면 총 4개의 상자가 한 개의 상자에 들어가게 된다.
 상자의 크기가 주어질 때, 한 번에 넣을 수 있는 최대의 상자 개수를 출력하는 프로그램을 작성하시오.
------------------------------------------------------------------------------------
 풀이 :
 LIS(최장 공통 부분 수열) 방식을 이용한 풀이하였다.
 - 현재 위치를 기준으로 왼쪽 위치에 대해서만 판별할 것.
 - 현재 상자의 크기 보다 작은 상자중 maximum 값이 가장 큰 값을 찾아 현재 상자의 maximum + 1하여 저장한다.
 
 -> 2차원 배열을 사용해서 저장하는 방식보단 좀 더 직관적인 vector를 초기화 하여 사용하였다.
 -> 현재 위치를 기준으로 왼쪽에 위치한 상자중 가장 많은 상자를 담고 있는 것을 찾는 것은 == 문제의 출력 조건인"한 줄에 넣을 수 있는 최대의 상자 개수를 출력한다."
 -> 현재 상자보다 왼쪽에 위치한 상자들 중 크기가 작은 상자가 담고 있는 박스는 결국, 현재 상자도 모두 담을 수 있다는 조건을 만족한다.
 -> 시간복잡도는 외부 루프 n번  * 내부루프 (n-1)로 O(n^2)의 시간복잡도를 가진다.
 ----------------------------------------------------------------------------------------
 LIS란?
 -> 주어진 여러 개의 수열 모두의 부분 수열이 되는 수열들 중에 가장 긴 것을 찾는 것.
*/

#include <iostream>
#include <vector>

using namespace std;

int arr[1005] = {};
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int n;
    cin >> n;
    
    vector<int> dist(n);
    
    for (int i = 0; i < n; i++)
        cin >> arr[i];
    
    int maximum = 0;
    
    for (int i = 0; i < n; i++)
    {
        maximum = 0;
        for (int j = 0; j < i; j++)
            if (arr[j] < arr[i] && maximum < dist[j])
                maximum = dist[j];
        dist[i] = maximum + 1;
    }
    
    maximum = 0;
    for (int i = 0; i < n; i++)
        if (maximum < dist[i])
            maximum = dist[i];
    
    cout << maximum << '\n';
}
