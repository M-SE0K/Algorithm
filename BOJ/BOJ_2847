/*
 문제 : BOJ_2847
 학교에서 그래픽스 수업을 들은 동준이는 수업시간에 들은 내용을 바탕으로 스마트폰 게임을 만들었다. 게임에는 총 N개의 레벨이 있고, 각 레벨을 클리어할 때 마다 점수가 주어진다. 플레이어의 점수는 레벨을 클리어하면서 얻은 점수의 합으로, 이 점수를 바탕으로 온라인 순위를 매긴다. 동준이는 레벨을 난이도 순으로 배치했다. 하지만, 실수로 쉬운레벨이 어려운 레벨보다 점수를 많이 받는 경우를 만들었다.
 이 문제를 해결하기 위해 동준이는 특정레벨의 점수를 감소시키려고 한다. 이렇게 해서 각 레벨을 클리어할 때 주는 점수가 증가하게 만들려고 한다.
 각 레벨을 클리어할 때 얻는 점수가 주어졌을 때, 몇 번 감소시키면 되는 지 구하는 프로그램을 작성하시오. 점수는 항상 양수이어야 하고, 1만큼 감소시키는 것이 1번이다. 항상 답이 존재하는 경우만 주어진다. 정답이 여러 가지인 경우네는 점수를 내리는 것을 최소한으로 하는 방법을 찾아야한다.
 ----------------------------------------------------------------------------------------------------------------------------------------------
 1. 레벨 순으로 점수가 부여 되며 점수는 랜덤이다. 이때 앞 레벨의 점수보다 점수는 높아야 하며 만약 낮은 경우 앞 레벨의 점수를 낮춘다. 점수는 무조건적으로 양수이다.
 2. 정답은 여러 가지이기에 가장 최소한으로 점수를 내리는 답안을 찾아야 한다.
 ----------------------------------------------------------------------------------------------------------------------------------------------
 풀이 : 이 문제는 정방향 순회, 역방향 순회 모두 큰 차이는 없지만, 풀이를 구상하였을 때 역방향이 조금 더 직관적이라고 느껴져 역방향으로 코드를 짰다.
 특정 레벨에서의 점수를 감소 시키는 횟수에 대한 최소합을 구하는 것. 즉, 점수를 올리는 것이 아니기에 입력 받은 점수는 최종적으로 오름차순으로 구성이 되어있어야 하기에 가장 끝 n-1번째 인덱스에 위치한 요소가 시작점이라고 생각함.
 */

#include <iostream>

using namespace std;

int arr[105];


int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int n;
    cin >> n;
    
    for (int i = 0; i < n; i++)
        cin >> arr[i];
    
    int score = 0;
    for (int i = n - 1; 0 < i; i--)
    {
        while(arr[i - 1] >= arr[i])
        {
            arr[i - 1] = arr[i - 1] - 1;
            score++;
        }
    }
    cout << score;
}
